import numpy as np
import matplotlib.pyplot as plt

def get_time_to(text, args, n1, n2):
    
    if text == 'f':
        return np.random.exponential(1./args['f'])
    
    if text == 'n1':
        M1 = args['M1']
        k1 = args['k1']
        
        if M1 > n1:
            return np.random.exponential(1./(k1*(M1-n1)))
        else:
            return np.inf
        
    if text == 'n2':
        M2 = args['M2']
        k2 = args['k2']
        if M2 > n2:
            return np.random.exponential(1./(k2*(M2-n2)))
        else:
            return np.inf
        
def get_arg_type(i):
    
    if i == 0:
        return 'f'
    if i == 1:
        return 'n1'
    if i == 2:
        return 'n2'
    else:
        return 'measure'

def to_dict(**x):
    return x

def run_test(args):

    run_time = args['run_time']
    
    M1 = args['M1']
    M2 = args['M2']
    
    c1 = args['c1']
    c2 = args['c2']
    
    p1 = args['p1']
    p2 = args['p2']
    
    pe = args['pe']
    
    
    tauv = args['tauv']
    vth = args['vth']

    delta_t = args['delta_t']
    
    current_time = 0
    v_membrane = 0
    
    n1 = 0
    n2 = 0
    
    v_history = [[0, current_time]] # data array
    AP_times = []

    preneuron_firing_history = []
    
    t_measure = delta_t
    
    while current_time < run_time:
        
        time_to_f = get_time_to('f', args, n1, n2) # next reaction time
        time_to_n1 = get_time_to('n1', args, n1, n2)
        time_to_n2 = get_time_to('n2', args, n1, n2)
            
        times_array = np.array([time_to_f, time_to_n1, time_to_n2, t_measure])
    
        t_min_arg = np.argmin(times_array)
        arg_type = get_arg_type(t_min_arg)
        t_min = times_array[t_min_arg]
    
        if arg_type == 'f':
            preneuron_firing_history.append(current_time)


            B = np.random.binomial(1, pe)
            b1 = np.random.binomial(n1, p1) # Number released
            b2 = np.random.binomial(n2, p2) # Number released
            b_pos = b1*B
            b_neg = b2*(1-B)
            voltage_addition = c1*b_pos-c2*b_neg
            
            if b_pos > 0:
                n1 -= b_pos
            else:
                n2 -= b_neg

            v_membrane += voltage_addition
            
            v_history.append([v_membrane, current_time])
            
            if v_membrane >= vth:
                v_membrane = 0
                AP_times.append(current_time)

            current_time += t_min
            t_measure -= t_min

        elif arg_type == 'n1':
            
            if n1 < M1:
                n1 += 1            
            
            current_time += t_min
            t_measure -= t_min
            
        elif arg_type == 'n2':
            
            if n2 < M2:
                n2 += 1            
            
            current_time += t_min
            t_measure -= t_min
            

        else:
            v_membrane = v_membrane*np.exp(-t_min/tauv)
            
            v_history.append([v_membrane, current_time])
    
            current_time += t_min
            t_measure = delta_t
            
    v_history = np.array(v_history) # data array
    AP_times = np.array(AP_times)
    
    inter_AP_times = np.diff(AP_times)
    if len(inter_AP_times) < 2:
        mean_inter_AP_time = np.nan
        CVT2 = np.nan
    else:
        mean_inter_AP_time = np.mean(inter_AP_times)
        CVT2 = np.var(inter_AP_times) / mean_inter_AP_time**2
    
    return {'v_history': np.array(v_history),
            'AP_times':np.array(AP_times),
            'inter_AP_times':np.array(inter_AP_times),
            'mean_T':mean_inter_AP_time, 
            'CVT2':CVT2}

def get_T_mean(p1e, cp1, f1, Hp1, p1s, k1, p2e, cp2, f2, Hp2, p2s, k2, c1, M1, c2, M2, vth, tauv):
    
    p1 = (p1e * (cp1 * f1)**Hp1 + p1s) / (1 + (cp1 * f1)**Hp1)
    p2 = (p2e * (cp2 * f2)**Hp2 + p2s) / (1 + (cp2 * f2)**Hp2)
    
    b1MeanSS = p1 * k1 * M1 / (f1 * p1 + k1)
    b2MeanSS = p2 * k2 * M2 / (f2 * p2 + k2)
        
    Tmean = tauv * np.log(1 / (1 - vth / (tauv * (c1 * f1 * b1MeanSS - c2 * f2 * b2MeanSS))))

    return Tmean


def get_CVT2(p1e, cp1, f1, Hp1, p1s, k1, p2e, cp2, f2, Hp2, p2s, k2, c1, M1, c2, M2, vth, tauv):
    
    p1 = (p1e * (cp1 * f1)**Hp1 + p1s) / (1 + (cp1 * f1)**Hp1)
    p2 = (p2e * (cp2 * f2)**Hp2 + p2s) / (1 + (cp2 * f2)**Hp2)
        
    b1MeanSS = p1 * k1 * M1 / (f1 * p1 + k1)
    b2MeanSS = p2 * k2 * M2 / (f2 * p2 + k2)
    
    b1SquaredMeanSS = (1 - p1) * b1MeanSS + b1MeanSS**2
    b2SquaredMeanSS = (1 - p2) * b2MeanSS + b2MeanSS**2
    
    CVT2 = -((vth * (vth - 2 * c1 * f1 * tauv * b1MeanSS + 2 * c2 * f2 * tauv * b2MeanSS) * (
        c1**2 * f1 * b1SquaredMeanSS + c2**2 * f2 * b2SquaredMeanSS
    )) / (2 * tauv * (c1 * f1 * b1MeanSS - c2 * f2 * b2MeanSS)**2 * (
        vth - c1 * f1 * tauv * b1MeanSS + c2 * f2 * tauv * b2MeanSS
    )**2 * np.log(1 - vth / (vth - c1 * f1 * tauv * b1MeanSS + c2 * f2 * tauv * b2MeanSS))**2))

    
    return CVT2


def get_equations(f1, f2, params):
    
    for param in params.keys():
        locals()[param] = params[param]
    
# =============================================================================
#     M1 = params['M1']
#     M2 = params['M2']
# 
#     c1 = params['c1']
#     c2 = params['c2']
# 
#     k1 = params['k1']
#     k2 = params['k2']
# 
#     p1s = params['p1s']
#     p2s = params['p2s']
# 
#     p1e = params['hp1']
#     p2e = params['hp2']
# 
#     cp1 = params['cp1']
#     cp2 = params['cp2']
# 
#     Hp1 = params['Hp1']
#     Hp2 = params['Hp2']
# 
#     vth = params['vth']
#     tauv = params['tauv']
# 
#     tauv = params['tauv']
#     vth = params['vth']
# =============================================================================
    
    T_mean = get_T_mean(p1e, cp1, f1, Hp1, p1s, k1, p2e, cp2, f2, Hp2, p2s, k2, c1, M1, c2, M2, vth, tauv)
    
    CVT2 = get_CVT2(p1e, cp1, f1, Hp1, p1s, k1, p2e, cp2, f2, Hp2, p2s, k2, c1, M1, c2, M2, vth, tauv)

    return T_mean, CVT2

###############################################################################
#
#                               Main Code
#
###############################################################################
# Test 1

# Values of c to test
f_max = 100
f_vals = np.arange(1,f_max+1)

run_time = 30

M1 = 100
M2 = 100

c1 = 0.01
c2 = 0.01

k1 = 100
k2 = 100

p1s = 0.3
p1e = 0

p2s = 0.3
p2e = 0

cp1 = 1
cp2 = 1

Hp1 = 1
Hp2 = 1

tauv = 1
vth = 0.4

delta_t = 0.01

# Simulations
mean_T_sim = []
CVT2_sim = []

fmax = 100
f_vals = np.arange(1, fmax+1)

ninit = 1

iter_range = range(1, len(f_vals))
for j1, i1 in enumerate(iter_range):
    for j2, i2 in enumerate(iter_range):
    
        f1 = f_vals[i1]
        f2 = f_vals[i2]
        
        params = to_dict(run_time = run_time, f1 = f1, f2 = f2, M1 = M1, M2 = M2,
                         c1 = c1, c2 = c2, k1 = k1, p1s = p1s, p1e = p1e, p2s = p2s, p2e = p2e,
                         cp1 = cp1, cp2 = cp2, Hp1 = Hp1, Hp2 = Hp2,
                         k2 = k2, tauv = tauv, vth = vth, delta_t = delta_t)  
        print(j1/len(iter_range))
    
        result = run_test(params)
    
        mean_T_sim.append(result['mean_T'])
        CVT2_sim.append(result['CVT2'])

# Equations
mean_T_eq = []
CVT2_eq = []

print('Equations')

for j, i in enumerate(iter_range):
    print(j/len(iter_range))
    T_mean_eq_val, CVT2T_eq_val = get_equations(f_vals[i], params)
    mean_T_eq.append(T_mean_eq_val)
    CVT2_eq.append(CVT2T_eq_val)

f_actual = [f for f in iter_range]

fig, ax = plt.subplots(1,2)
ax[0].plot(f_actual, mean_T_sim, label = '<T> Simulations')
ax[0].plot(f_actual, mean_T_eq, label = '<T> Equation')
ax[1].plot(f_actual, CVT2_sim, label = 'CVT2 Simulations')
ax[1].plot(f_actual, CVT2_eq, label = 'CVT2 Equation')
ax[0].legend()
ax[1].legend()
plt.show()
