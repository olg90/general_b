from numpy import inf, argmin, array, exp, var, nan, mean, diff, log, linspace
from numpy.random import exponential, binomial

import matplotlib.pyplot as plt

def get_time_to(text, f, k1, M1, n1, k2, M2, n2):
    
    if text == 'f':
        return exponential(1./f)
    
    if text == 'n1':
        if M1 > n1:
            return exponential(1./(k1*(M1-n1)))
        else:
            return inf
        
    if text == 'n2':
        if M2 > n2:
            return exponential(1./(k2*(M2-n2)))
        else:
            return inf
        
def get_arg_typi(i):
    
    if i == 0:
        return 'f'
    if i == 1:
        return 'pf'
    if i == 2:
        return 'n1'
    if i == 3:
        return 'n2'
    else:
        return 'measure'

def to_dict(**x):
    return x

def run_test(f, run_time, c1, M1, k1, p1, c2, k2, M2, p2, tau2, tau3, vth2, vth3, delta_t):
        
    current_time = 0
    
    v2 = 0
    v3 = 0

    n1 = 0
    n2 = 0

    v2_history = [[0, current_time]] # data array
    v3_history = [[0, current_time]] # data array
    
    AP_times2 =  []
    AP_times3 = []

# =============================================================================
#     preneuron_firing_history = []
# =============================================================================

    t_measure = delta_t
    
    while current_time < run_time:
        
        time_to_f = get_time_to('f', f, k1, M1, n1, k2, M2, n2) # next reaction time
        time_to_n1 = get_time_to('n1', f, k1, M1, n1, k2, M2, n2)
        time_to_n2 = get_time_to('n2', f, k1, M1, n1, k2, M2, n2)
            
        times_array = [time_to_f, time_to_n1, time_to_n2, t_measure]
    
        t_min_arg = argmin(times_array)
        arg_typi = get_arg_typi(t_min_arg)
        t_min = times_array[t_min_arg]

        if arg_typi == 'f':

            b1 = binomial(n1, p1) # Number released
            if (b1 > 0) and (n1 >= b1):
                n1 -= b1

            vadd123 = c1*b1
                
            v3 += vadd123
            v2 += vadd123

            if v2 >= vth2:
                
                b2 = binomial(n2, p2) # Number released
                if (b2 > 0) and (n2 >= b2):
                    n2 -= b2          
                vadd23 = c2*b2
                v3 -= vadd23
                v2_history.append([v2, current_time])   
                v3_history.append([v3, current_time])
                 
                AP_times2.append(current_time)
                v2 = 0
                if v3>vth3:
                    AP_times3.append(current_time)
                    v3 = 0
                
            elif v2 < vth2:
                
                v2_history.append([v2, current_time])                    
                v3_history.append([v3, current_time])
                if v3 > vth3:
                    AP_times3.append([v3, current_time])
                    v3 = 0

            current_time += t_min
            t_measure -= t_min

        elif arg_typi == 'n1':
            
            if n1 < M1:
                n1 += 1
            
            current_time += t_min
            t_measure -= t_min
            
        elif arg_typi == 'n2':
            
            if n2 < M2:
                n2 += 1            
            
            current_time += t_min
            t_measure -= t_min
            
        else:
            v3 = v3*exp(-t_min/tau3)
            v3_history.append([v3, current_time])
            
            v2 = v2*exp(-t_min/tau2)
            v2_history.append([v2, current_time])
    
            current_time += t_min
            t_measure = delta_t
            
            
    v2_history = array(v2_history) # data array
    AP_times2 = array(AP_times2)
    v3_history = array(v3_history) # data array
    AP_times3 = array(AP_times3)
    
    inter_AP_times3 = diff(AP_times3)
    if len(inter_AP_times3) < 2:
        mean_inter_AP_time3 = nan
        CVT23 = nan
    else:
        mean_inter_AP_time3 = mean(inter_AP_times3)
        CVT23 = var(inter_AP_times3) / mean_inter_AP_time3**2
        
        
    inter_AP_times2 = diff(AP_times2)
    if len(inter_AP_times2) < 2:
        mean_inter_AP_time2 = nan
        CVT23 = nan
    else:
        mean_inter_AP_time2 = mean(inter_AP_times2)
        CVT22 = var(inter_AP_times2) / mean_inter_AP_time2**2
    
    return {'v3_history': array(v3_history),
            'v2_history': array(v2_history),
# =============================================================================
#             'AP_times3':array(AP_times3),
#             'AP_times2':array(AP_times2),
# =============================================================================
            'mean_T2':mean_inter_AP_time2, 
            'CVT22':CVT22,
            'mean_T3':mean_inter_AP_time3, 
            'CVT23':CVT23}

def get_stats(f, run_time, c1, M1, k1, p1, c2, k2, M2, p2, tau2, tau3, vth2, vth3, delta_t):
    result = run_test(f, run_time, c1, M1, k1, p1, c2, k2, M2, p2, tau2, tau3, vth2, vth3, delta_t)

    mean_T_sim=result['mean_T']
    CVT2_sim=result['CVT2']
    pf_sim=1/(f*result['mean_T'])
    
# =============================================================================
#     pf = get_pi(f, c1, k1, M1, p1, vth, tau3)
# =============================================================================
    params = to_dict(run_time = run_time, f = f, M1 = M1, M2 = M2,
                     p1 = p1, p2 = p2, c1 = c1, c2 = c2, k1 = k1, pi = pi, 
                     k2 = k2, tau3 = tau3, vth = vth, delta_t = delta_t)  
    pf_eq=1/(f*T_mean_eq_val)

    return mean_T_sim, T_mean_eq_val, CVT2_sim, CVT2_eq_val, pf_sim, pf_eq

###############################################################################
#
#                               Main Code
#
###############################################################################
# Test 1

#######################
run_time = 10
f = 50

p1 = 0.2 # 0.2
p2 = 0.02 # 0.02

M1 = 100 # 100
M2 = 100 # 100

c1 = 0.01 # 0.01
c2 = 0.01 # 0.01

k1 = 1 # 1
k2 = 10 # 10

tau3 = 1 # 1
vth = 0.2 #0.2
delta_t = 0.01

ntimes = 100
fmax=200
fvals = np.linspace(0, fmax, ntimes)

Ts = []
Te = []

for i,f in enumerate(k1_list):
    print(i/ntimes)
    data = get_stats(f, run_time, c1, M1, k1, p1, c2, k2, M2, p2, pi, tau3, vth, delta_t)
    mean_T_sim, mean_T_eq, CVT2_sim, CVT2_eq, pf_sim, pf_eq = data
    Ts.append(1/mean_T_sim)
    Te.append(1/mean_T_eq)
    

#

# Set a constant font size
font_size = 25

cb = '#1f77b4'
co = '#ff7f0e'

# Plotting Ts and Te with legends and axis labels

plt.plot(k1_list, Ts, label='simulations', linewidth = 5, linestyle='--', color=cb)
plt.plot(k1_list, Te, label='theoretical', linewidth = 5, linestyle='-', color=co)

# Legends
plt.legend(fontsize=font_size-5)

# Axis labels
plt.xlabel(f'input frequency $f$, $Hz$', fontsize=font_size)
plt.ylabel(f'output frequency $\\langle F \\rangle$, $Hz$', fontsize=font_size)

# Title if needed

plt.tick_params(axis='both', labelsize = font_size)

# Tick parameters
plt.xticks(fontsize=font_size)
plt.yticks(fontsize=font_size)

plt.grid(True, alpha = 0.6)

# Show the plot
plt.show()

#




# =============================================================================
# params = to_dict(run_time = run_time, f = f, M1 = M1, M2 = M2,
#                  p1 = p1, p2 = p2, c1 = c1, c2 = c2, k1 = k1, pi = pi, 
#                  k2 = k2, tau3 = tau3, vth = vth, delta_t = delta_t)  
# result = run_test(params)
# =============================================================================


# =============================================================================
# vh = result['v3_history']
# 
# =============================================================================
# =============================================================================
# import os
# os.chdir(r'C:\Users\olive\OneDrive\Desktop\PhD\Research\Neuron\IFL')
# vho= np.load('vhol.npy')
# =============================================================================


#%%

# =============================================================================
# # Example data
# vst = 0
# nsec = 2
# add = 10000 * nsec
# vln = vst + add
# 
# # Font settings
# fontsize = 20
# font_family = 'Arial'
# 
# plt.subplot(2, 1, 1)
# plt.axhline(vth, 0, 3, label='AP threshold$=0.07$ $volts$', color='k',
#             linewidth=2, linestyle='-')
# plt.plot(vho[:, 1][vst:vln], vho[:, 0][vst:vln], linewidth=1.5, label='membrane potential')
# plt.xticks([])
# plt.yticks(fontsize=fontsize)
# plt.tick_params(axis='both', labelsize=fontsize)
# plt.ylim([0, vth + 0.05])
# plt.xlim([0, nsec])
# plt.text(1.5, 0.1, 'Open loop', fontsize=fontsize - 5, fontname=font_family)
# plt.legend(loc='upper left', fontsize=fontsize - 5, bbox_to_anchor=(0, 1.3), framealpha=1, edgecolor='k', shadow=True)
# 
# plt.subplot(2, 1, 2)
# plt.axhline(vth, 0, 3, label='AP threshold $v_{{th}}=0.07$ $volts$', color='k',
#             linewidth=2, linestyle='-')
# plt.plot(vh[:, 1][vst:vln], vh[:, 0][vst:vln], linewidth=1.5, label='membrane potential $v(t), volts$')
# plt.ylabel('                      membrane potential $v$, $volts$', fontsize=fontsize, fontname=font_family)
# plt.xlabel('time $t$, $sec$', fontsize=fontsize, fontname=font_family)
# plt.xticks(fontsize=fontsize)
# plt.yticks(fontsize=fontsize)
# plt.tick_params(axis='both', labelsize=fontsize)
# plt.ylim([0, vth + 0.05])
# plt.xlim([0, nsec])
# plt.text(1.05, 0.1, 'Incoherent feed-forward', fontsize=fontsize - 5, fontname=font_family)
# 
# plt.show()
# =============================================================================


ntimes = 100
k1_list = np.linspace(0,100,ntimes)


Ts = []
Te = []

for i,f in enumerate(k1_list):
    print(i/ntimes)
    data = get_stats(f, run_time, c1, M1, k1, p1, c2, k2, M2, p2, pi, tau3, vth, delta_t)
    mean_T_sim, mean_T_eq, CVT2_sim, CVT2_eq, pf_sim, pf_eq = data
    Ts.append(1/mean_T_sim)
    Te.append(1/mean_T_eq)
    



# =============================================================================
# # heatmap of pf for vth vs f
# nx = 50
# xs=np.linspace(0, 1, nx)
# ntimes=50
# f_vals = np.linspace(0, 100, ntimes)
# datasets = np.zeros((nx, ntimes))
# for j, vth in enumerate(xs): # modify here j, X <--
#     print(j/nx)
#     for i,f in enumerate(f_vals):
#         data = get_stats(f, run_time, c1, M1, k1, p1, c2, k2, M2, p2, pi, tau3, vth, delta_t)
#         mean_T_sim, mean_T_eq, CVT2_sim, CVT2_eq, pf_sim, pf_eq = data
#         datasets[j,i] = pf_sim
# datasets = np.array(datasets)
#     
# 
# # Assuming 'datasets', 'f_vals', and 'xs' are defined
# 
# num_ticks = 5
# x_tick_locs = np.linspace(min(f_vals), max(f_vals), num_ticks)
# y_tick_locs = np.linspace(min(xs), max(xs), num_ticks)
# 
# fontsize = 20
# 
# plt.imshow(datasets, origin='lower', cmap='rainbow', aspect='auto', extent=(min(f_vals), max(f_vals), min(xs), max(xs)), vmin=0, vmax=1)
# colorbar = plt.colorbar(orientation='vertical')  # Use orientation='horizontal' for horizontal colorbar
# 
# # Rotate colorbar label
# colorbar.set_label(f'postsynaptic firing probability', fontsize=fontsize, rotation=270, labelpad=30)  # Adjust rotation and labelpad accordingly
# colorbar.ax.tick_params(labelsize=fontsize)
# 
# plt.xlabel(f'input frequency $f$, $Hz$', fontsize=fontsize)
# plt.ylabel(f'AP-firing threshold $vth$, $volts$', fontsize=fontsize)
# 
# # Set the tick locations and labels
# plt.xticks(x_tick_locs, fontsize=fontsize)
# plt.yticks(y_tick_locs, fontsize=fontsize)
# 
# plt.show()
# =============================================================================

# =============================================================================
# num_ticks = 5
# x_tick_locs = np.linspace(min(f_vals), max(f_vals), num_ticks)
# y_tick_locs = np.linspace(min(xs), max(xs), num_ticks)
# 
# fontsize = 20
# 
# plt.imshow(datasets, origin='lower', cmap='rainbow', aspect='auto', extent=(min(f_vals), max(f_vals), min(xs), max(xs)), vmin=0, vmax=1)
# colorbar = plt.colorbar(orientation='vertical')  # Use orientation='horizontal' for horizontal colorbar
# colorbar.set_label(f'firing probability $p(f)$', fontsize=fontsize)  # Adjust 'Colorbar Label' accordingly
# colorbar.ax.tick_params(labelsize=fontsize)
# plt.xlabel(f'input frequency $f$, $Hz$', fontsize=fontsize)
# plt.ylabel(f'AP-firing threshold $vth$, $volts$', fontsize=fontsize)
# 
# # Set the tick locations and labels
# plt.xticks(x_tick_locs, fontsize=fontsize)
# plt.yticks(y_tick_locs, fontsize=fontsize)
# 
# plt.show()
# =============================================================================
#%%






# =============================================================================
# nx = 50
# xs=np.linspace(0, 1, nx)
# datasets=np.zeros(nx)
# for j, vth in enumerate(xs): # modify here j, X <--
#     print(j/nx)
#     data = get_stats(f, run_time, c1, M1, k1, p1, c2, k2, M2, p2, pi, tau3, vth, delta_t)
#     mean_T_sim, mean_T_eq, CVT2_sim, CVT2_eq, pf_sim, pf_eq = data
#     datasets[j] = pf_sim
# datasets = np.array(datasets)
# 
# plt.plot(xs, datasets)
# 
# =============================================================================




# =============================================================================
# datasets = []
# ntimes = 100
# f_vals = np.linspace(0, 100, ntimes)
# for i,f in enumerate(f_vals):
#     print(i/ntimes)
#     data = get_stats(f, run_time, c1, M1, k1, p1, c2, k2, M2, p2, pi, tau3, vth, delta_t)
#     mean_T_sim, mean_T_eq, CVT2_sim, CVT2_eq, pf_sim, pf_eq = data
#     datasets.append(data)
# =============================================================================

# =============================================================================
# datasets = np.array(datasets)
# Fs = 1/datasets[:,0]
# Fe = 1/datasets[:,1]
# 
# plt.plot(f_vals, Fs)
# plt.plot(f_vals, Fe)
# plt.show()
# 
# =============================================================================
#%%
# =============================================================================
# 
# F_sim = 1/np.array(mean_T_sim)
# F_eq = 1/np.array(mean_T_eq)
# 
# fontsize = 20
# fig, ax = plt.subplots(1, 3, figsize=(15, 5))  # Set figsize to adjust the overall width of the figure
# 
# # Subplot 1
# ax[0].plot(f_vals, F_sim, label='simulations')
# ax[0].plot(f_vals, F_eq, label='equation')
# ax[0].set_xlabel('excitatory firing frequency, $f_e$ (Hz)', fontsize=fontsize)
# ax[0].set_ylabel(r'mean output frequency, $\langle F \rangle$ (Hz)', fontsize=fontsize)
# ax[0].tick_params(axis='both', labelsize=fontsize)
# ax[0].legend(loc='uppir left', fontsize=fontsize-5)
# 
# # Subplot 2
# ax[1].plot(f_vals, CVT2_sim, label='simulations')
# ax[1].set_xlabel('excitatory firing frequency, $f_e$ (Hz)', fontsize=fontsize)
# ax[1].set_ylabel(r'noise, $CV^2_T$', fontsize=fontsize)
# ax[1].tick_params(axis='both', labelsize=fontsize)
# ax[1].legend(loc='uppir right', fontsize=fontsize-5)
# 
# # Subplot 3
# # Assuming pf_sim and pf_eq are defined elsewhere
# ax[2].plot(f_vals, pf_sim, label='simulations')
# ax[2].plot(f_vals, pf_eq, label='equation')
# ax[2].set_xlabel('excitatory firing frequency, $f_e$ (Hz)', fontsize=fontsize)
# ax[2].set_ylabel('probability of postsynaptic\nneuron firing p(f)', fontsize=fontsize)  # Add a ylabel appropriate for pf_sim and pf_eq
# ax[2].tick_params(axis='both', labelsize=fontsize)
# ax[2].legend(loc='uppir left', fontsize=fontsize-5)
# 
# plt.tight_layout()
# plt.show()
# 
# 
# =============================================================================
